#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
LifeShot Auth Stack Bootstrap (Boto3)
- Creates Cognito User Pool + App Client (no secret)
- Creates Groups: Admins, Lifeguards
- Creates 2 users + assigns to groups
- Deploys Node Lambda: LifeShot_Login (LOGIN.MJS autogenerated + npm install + zip)
- Creates/Ensures HTTP API (API Gateway v2 HTTP) with routes:
    /auth/login             POST   (NONE)
    /auth/complete-password POST   (NONE)
    /auth/me                GET    (NONE)
    /auth/logout            POST   (NONE)
    /events                 GET    (JWT Auth)   -> Events API Lambda (LifeShot_Api_Handler)
    /events                 PATCH  (JWT Auth)   -> Events API Lambda (LifeShot_Api_Handler)
- CORS for API Gateway: AllowOrigins ["*"], AllowHeaders ["authorization","content-type"],
  AllowMethods ["GET","POST","PATCH","OPTIONS"], AllowCredentials false
- Ensures Detector Lambda has a Function URL (Auth NONE) + CORS (POST/OPTIONS)
- SNS Topic + Access Policy + Email subscription
- Split Detector into 3 Lambdas (Detector / RenderAndS3 / EventsAndSNS)
    - Detector env vars: RENDER_LAMBDA_NAME + EVENTS_LAMBDA_NAME (points to EventsAndSNS)
    - EventsAndSNS env vars: SNS_TOPIC_ARN
    - Detector does NOT store SNS_TOPIC_ARN

IMPORTANT:
- This script uses LabRole by default (no IAM creation in lab environments).
- If split lambdas (Detector/Render/EventsAndSNS) or Events API lambda don't exist,
  this script will CREATE placeholders from scratch (with simple Python handlers) so it can build everything from 0.

Requirements on your machine:
- python3 + boto3 installed
- node + npm installed (for packaging login lambda with @aws-sdk/client-cognito-identity-provider)
"""

import base64
import json
import os
import shutil
import subprocess
import sys
import tempfile
import time
import zipfile
from dataclasses import dataclass
from typing import Dict, Optional, Tuple, Any, List

import boto3
from botocore.exceptions import ClientError


# -------------------------
# Config (env overrides)
# -------------------------
REGION = os.getenv("AWS_REGION", "us-east-1")
STACK_PREFIX = os.getenv("STACK_PREFIX", "LifeShot")

USER_POOL_NAME = os.getenv("USER_POOL_NAME", f"{STACK_PREFIX}_UserPool")
APP_CLIENT_NAME = os.getenv("APP_CLIENT_NAME", "lifeshot-spa")

LOGIN_LAMBDA_NAME = os.getenv("LOGIN_LAMBDA_NAME", f"{STACK_PREFIX}_Login")

# Existing "API events" lambda used by API Gateway /events routes:
EVENTS_API_LAMBDA_NAME = os.getenv("EVENTS_API_LAMBDA_NAME", "LifeShot_Api_Handler")

# Split lambdas:
DETECTOR_LAMBDA_NAME = os.getenv("DETECTOR_LAMBDA_NAME", "LifeShot_detector_logic")
RENDER_LAMBDA_NAME = os.getenv("RENDER_LAMBDA_NAME", "LifeShot_RenderAndS3")
EVENTS_SNS_LAMBDA_NAME = os.getenv("EVENTS_SNS_LAMBDA_NAME", "LifeShot_EventsAndSNS")

# Handlers (because you renamed files - not lambda_function.py)
DETECTOR_HANDLER = os.getenv("DETECTOR_HANDLER", "detector_logic.lambda_handler")
RENDER_HANDLER = os.getenv("RENDER_HANDLER", "render_and_s3.lambda_handler")
EVENTS_SNS_HANDLER = os.getenv("EVENTS_SNS_HANDLER", "events_and_sns.lambda_handler")

# Memory requirements
DETECTOR_MEMORY = int(os.getenv("DETECTOR_MEMORY", "1024"))
RENDER_MEMORY = int(os.getenv("RENDER_MEMORY", "1024"))
EVENTS_SNS_MEMORY = int(os.getenv("EVENTS_SNS_MEMORY", "256"))

# Timeouts
DETECTOR_TIMEOUT = int(os.getenv("DETECTOR_TIMEOUT", "60"))
RENDER_TIMEOUT = int(os.getenv("RENDER_TIMEOUT", "45"))
EVENTS_SNS_TIMEOUT = int(os.getenv("EVENTS_SNS_TIMEOUT", "15"))

API_NAME = os.getenv("API_NAME", f"{STACK_PREFIX}HttpApi")

ALLOWED_ORIGIN = os.getenv("ALLOWED_ORIGIN", "http://localhost:5500")

# Users to create
ADMIN_EMAIL = os.getenv("ADMIN_EMAIL", "lifeguard647@gmail.com")
GUARD_EMAIL = os.getenv("GUARD_EMAIL", "lifeguarduser1@gmail.com")
TEMP_PASSWORD = os.getenv("TEMP_PASSWORD", "LifeShot!123")

GROUP_ADMINS = "Admins"
GROUP_LIFEGUARDS = "Lifeguards"

# SNS
SNS_TOPIC_NAME = os.getenv("SNS_TOPIC_NAME", "LifeShot-Drowning-Alerts")

# LabRole (default)
LAB_ROLE_NAME = os.getenv("LAB_ROLE_NAME", "LabRole")

# Runtime defaults
LOGIN_RUNTIME = os.getenv("LOGIN_RUNTIME", "nodejs20.x")
DEFAULT_PY_RUNTIME = os.getenv("DEFAULT_PY_RUNTIME", "python3.11")


# -------------------------
# Helpers
# -------------------------
def retry_on_conflict(fn, *, retries: int = 12, delay_sec: int = 3):
    last = None
    for _ in range(retries):
        try:
            return fn()
        except ClientError as e:
            code = e.response.get("Error", {}).get("Code", "")
            if code == "ResourceConflictException":
                last = e
                time.sleep(delay_sec)
                continue
            raise
    raise last


def log(msg: str) -> None:
    print(f"[{time.strftime('%H:%M:%S')}] {msg}")


def die(msg: str) -> None:
    print(f"ERROR: {msg}", file=sys.stderr)
    sys.exit(1)


def need_cmd(cmd: str) -> None:
    if shutil.which(cmd) is None:
        die(f"Missing command on PATH: {cmd}")


def b64_zip_bytes(path: str) -> bytes:
    with open(path, "rb") as f:
        return f.read()


def safe_client(service: str):
    return boto3.client(service, region_name=REGION)


def get_account_id(sts) -> str:
    return sts.get_caller_identity()["Account"]


def wait_lambda_active(client_lambda, fn_name: str, timeout_sec: int = 180) -> None:
    """
    Wait until a Lambda function is Active. Prevents ResourceConflictException
    when updating config/env right after create/update.
    """
    try:
        waiter = client_lambda.get_waiter("function_active")
        waiter.wait(
            FunctionName=fn_name,
            WaiterConfig={"Delay": 3, "MaxAttempts": max(1, timeout_sec // 3)},
        )
        return
    except Exception:
        # fallback polling
        t0 = time.time()
        while time.time() - t0 < timeout_sec:
            try:
                cfg = client_lambda.get_function_configuration(FunctionName=fn_name)
                if cfg.get("State") == "Active":
                    return
            except ClientError:
                pass
            time.sleep(3)
        raise RuntimeError(f"Lambda did not become Active in time: {fn_name}")


def ensure_lambda_permission_invoke(
    client_lambda,
    fn_name: str,
    statement_id: str,
    principal: str,
    action: str,
    source_arn: Optional[str] = None,
    function_url_auth_type: Optional[str] = None,
) -> None:
    kwargs = {
        "FunctionName": fn_name,
        "StatementId": statement_id,
        "Action": action,
        "Principal": principal,
    }
    if source_arn:
        kwargs["SourceArn"] = source_arn
    if function_url_auth_type:
        kwargs["FunctionUrlAuthType"] = function_url_auth_type

    def _call():
        return client_lambda.add_permission(**kwargs)

    try:
        retry_on_conflict(_call)
        log(f"Added lambda permission: {fn_name} {statement_id}")
    except ClientError as e:
        code = e.response.get("Error", {}).get("Code", "")
        msg = e.response.get("Error", {}).get("Message", "") or str(e)

        # ✅ Treat "statement id already exists" as success (idempotent)
        if code in ("ResourceConflictException", "EntityAlreadyExistsException"):
            if "already exists" in msg.lower() or "statement id" in msg.lower():
                log(f"Lambda permission already exists: {fn_name} {statement_id}")
                return

        raise


def merge_env(existing: Optional[Dict[str, str]], updates: Dict[str, Optional[str]]) -> Dict[str, str]:
    cur = dict(existing or {})
    for k, v in updates.items():
        if v is None:
            cur.pop(k, None)
        else:
            cur[k] = v
    return cur


def zip_from_dir(src_dir: str, out_zip: str) -> None:
    with zipfile.ZipFile(out_zip, "w", compression=zipfile.ZIP_DEFLATED) as z:
        for root, _, files in os.walk(src_dir):
            for f in files:
                full = os.path.join(root, f)
                rel = os.path.relpath(full, src_dir)
                z.write(full, rel)


# -------------------------
# Node Login Lambda source (exactly like your bash)
# -------------------------
LOGIN_MJS = r"""import {
  CognitoIdentityProviderClient,
  InitiateAuthCommand,
  RespondToAuthChallengeCommand,
} from "@aws-sdk/client-cognito-identity-provider";

// ===============================
// ENV
// ===============================
const REGION = process.env.COGNITO_REGION || "us-east-1";
const CLIENT_ID = process.env.COGNITO_CLIENT_ID;
const ALLOWED_ORIGIN = process.env.ALLOWED_ORIGIN || "http://localhost:5500";

if (!CLIENT_ID) console.warn("Missing env COGNITO_CLIENT_ID");

const cognito = new CognitoIdentityProviderClient({ region: REGION });

// ===============================
// HELPERS
// ===============================
function corsHeaders(origin) {
  const reqOrigin = origin || "";
  const allowOrigin = reqOrigin && reqOrigin === ALLOWED_ORIGIN ? reqOrigin : ALLOWED_ORIGIN;

  return {
    "Access-Control-Allow-Origin": allowOrigin,
    "Access-Control-Allow-Headers": "content-type,authorization",
    "Access-Control-Allow-Methods": "GET,POST,PATCH,OPTIONS",
    "Access-Control-Allow-Credentials": "false",
    "Vary": "Origin",
  };
}

function json(statusCode, bodyObj, origin, extraHeaders = {}) {
  return {
    statusCode,
    headers: {
      "Content-Type": "application/json",
      ...corsHeaders(origin),
      ...extraHeaders,
    },
    body: JSON.stringify(bodyObj),
  };
}

function parseJsonBody(event) {
  try {
    if (!event.body) return {};
    return typeof event.body === "string" ? JSON.parse(event.body) : event.body;
  } catch {
    return {};
  }
}

function decodeJwtPayload(token) {
  try {
    const parts = String(token || "").split(".");
    if (parts.length < 2) return null;
    const b64 = parts[1].replace(/-/g, "+").replace(/_/g, "/");
    const padded = b64 + "===".slice((b64.length + 3) % 4);
    const jsonStr = Buffer.from(padded, "base64").toString("utf8");
    return JSON.parse(jsonStr);
  } catch {
    return null;
  }
}

function getRoleFromGroups(groups) {
  const g = (groups || []).map((x) => String(x).toLowerCase());
  if (g.includes("admins") || g.includes("admin")) return "admin";
  if (g.includes("lifeguards") || g.includes("lifeguard") || g.includes("guard")) return "guard";
  return "unknown";
}

function getBearerToken(event) {
  const h = event.headers || {};
  const auth = h.authorization || h.Authorization || "";
  const m = String(auth).match(/^Bearer\s+(.+)$/i);
  return m ? m[1].trim() : "";
}

// ===============================
// ROUTES
// ===============================
async function routeLogin(event, origin) {
  const body = parseJsonBody(event);
  const username = String(body.username || "").trim();
  const password = String(body.password || "").trim();

  if (!username || !password) {
    return json(400, { message: "username and password are required" }, origin);
  }

  const cmd = new InitiateAuthCommand({
    AuthFlow: "USER_PASSWORD_AUTH",
    ClientId: CLIENT_ID,
    AuthParameters: { USERNAME: username, PASSWORD: password },
  });

  try {
    const resp = await cognito.send(cmd);

    if (resp.ChallengeName === "NEW_PASSWORD_REQUIRED") {
      const challengeUsername =
        resp.ChallengeParameters?.USER_ID_FOR_SRP || username;

      return json(
        409,
        {
          ok: false,
          challenge: "NEW_PASSWORD_REQUIRED",
          session: resp.Session || "",
          username: challengeUsername,
          message: "New password required",
        },
        origin
      );
    }

    const auth = resp.AuthenticationResult || {};
    const accessToken = auth.AccessToken || "";
    const idToken = auth.IdToken || "";
    const refreshToken = auth.RefreshToken || "";
    const expiresIn = Number(auth.ExpiresIn || 3600);

    if (!accessToken || !idToken) {
      return json(401, { message: "Login failed (no tokens returned)" }, origin);
    }

    const payload = decodeJwtPayload(idToken) || {};
    const groups = Array.isArray(payload["cognito:groups"]) ? payload["cognito:groups"] : [];
    const role = getRoleFromGroups(groups);

    return json(
      200,
      {
        ok: true,
        role,
        username: payload["cognito:username"] || username,
        email: payload["email"] || "",
        groups,
        expiresIn,
        accessToken,
        idToken,
        refreshToken,
      },
      origin
    );
  } catch (err) {
    return json(
      401,
      { message: "Login failed", detail: err?.name || "AuthError", reason: err?.message || "" },
      origin
    );
  }
}

async function routeCompletePassword(event, origin) {
  const body = parseJsonBody(event);
  const username = String(body.username || "").trim();
  const newPassword = String(body.newPassword || "").trim();
  const session = String(body.session || "").trim();

  if (!username || !newPassword || !session) {
    return json(400, { message: "username, newPassword and session are required" }, origin);
  }

  const cmd = new RespondToAuthChallengeCommand({
    ClientId: CLIENT_ID,
    ChallengeName: "NEW_PASSWORD_REQUIRED",
    Session: session,
    ChallengeResponses: {
      USERNAME: username,
      NEW_PASSWORD: newPassword,
    },
  });

  try {
    const resp = await cognito.send(cmd);
    const auth = resp.AuthenticationResult || {};

    const accessToken = auth.AccessToken || "";
    const idToken = auth.IdToken || "";
    const refreshToken = auth.RefreshToken || "";
    const expiresIn = Number(auth.ExpiresIn || 3600);

    if (!accessToken || !idToken) {
      return json(401, { message: "Password change succeeded but no tokens returned" }, origin);
    }

    const payload = decodeJwtPayload(idToken) || {};
    const groups = Array.isArray(payload["cognito:groups"]) ? payload["cognito:groups"] : [];
    const role = getRoleFromGroups(groups);

    return json(
      200,
      {
        ok: true,
        role,
        username: payload["cognito:username"] || username,
        email: payload["email"] || "",
        groups,
        expiresIn,
        accessToken,
        idToken,
        refreshToken,
      },
      origin
    );
  } catch (err) {
    return json(
      401,
      { message: "Password change failed", detail: err?.name || "ChallengeError", reason: err?.message || "" },
      origin
    );
  }
}

async function routeMe(event, origin) {
  const token = getBearerToken(event);
  if (!token) return json(401, { ok: false, message: "Missing Bearer token" }, origin);

  const payload = decodeJwtPayload(token);
  if (!payload) return json(401, { ok: false, message: "Invalid token" }, origin);

  const groups = Array.isArray(payload["cognito:groups"]) ? payload["cognito:groups"] : [];
  const role = getRoleFromGroups(groups);

  return json(
    200,
    {
      ok: true,
      role,
      username: payload["cognito:username"] || payload["username"] || "",
      email: payload["email"] || "",
      groups,
    },
    origin
  );
}

async function routeLogout(event, origin) {
  return json(200, { ok: true }, origin);
}

export const handler = async (event) => {
  const method = event.requestContext?.http?.method || event.httpMethod || "";
  const path = event.requestContext?.http?.path || event.rawPath || event.path || "";
  const origin = event.headers?.origin || event.headers?.Origin || "";

  if (method === "OPTIONS") {
    return { statusCode: 204, headers: corsHeaders(origin), body: "" };
  }

  if (method === "POST" && path.endsWith("/auth/login")) return routeLogin(event, origin);
  if (method === "POST" && path.endsWith("/auth/complete-password")) return routeCompletePassword(event, origin);
  if (method === "GET"  && path.endsWith("/auth/me")) return routeMe(event, origin);
  if (method === "POST" && path.endsWith("/auth/logout")) return routeLogout(event, origin);

  return json(404, { message: "Not found", path, method }, origin);
};
"""

PACKAGE_JSON = {
    "name": "lifeshot-login",
    "version": "1.0.0",
    "type": "module",
    "dependencies": {
        "@aws-sdk/client-cognito-identity-provider": "^3.600.0"
    }
}


# -------------------------
# Placeholder Lambda code to allow full "from 0"
# -------------------------
def make_placeholder_zip(module_name: str, out_zip: str) -> None:
    """
    Creates a tiny python lambda module with lambda_handler(event, context) returning a JSON-like dict.
    module_name example: 'detector_logic' or 'render_and_s3' or 'events_and_sns'
    """
    with tempfile.TemporaryDirectory() as td:
        py_path = os.path.join(td, f"{module_name}.py")
        with open(py_path, "w", encoding="utf-8") as f:
            f.write(
                "import json\n"
                "def lambda_handler(event, context):\n"
                "    return {\n"
                "        'statusCode': 200,\n"
                "        'headers': {'Content-Type': 'application/json'},\n"
                "        'body': json.dumps({'ok': True, 'module': __name__, 'note': 'PLACEHOLDER - replace with real code'})\n"
                "    }\n"
            )
        zip_from_dir(td, out_zip)


def make_events_api_placeholder_zip(out_zip: str) -> None:
    with tempfile.TemporaryDirectory() as td:
        py_path = os.path.join(td, "lambda_function.py")
        with open(py_path, "w", encoding="utf-8") as f:
            f.write(
                "import json\n"
                "def lambda_handler(event, context):\n"
                "    # Placeholder for LifeShot_Api_Handler\n"
                "    return {\n"
                "        'statusCode': 200,\n"
                "        'headers': {'Content-Type': 'application/json'},\n"
                "        'body': json.dumps({'ok': True, 'note': 'PLACEHOLDER /events API'})\n"
                "    }\n"
            )
        zip_from_dir(td, out_zip)


# -------------------------
# Cognito
# -------------------------
def ensure_user_pool(cognito, user_pool_name: str) -> str:
    pools = cognito.list_user_pools(MaxResults=60).get("UserPools", [])
    for p in pools:
        if p.get("Name") == user_pool_name:
            return p["Id"]

    resp = cognito.create_user_pool(
        PoolName=user_pool_name,
        UsernameAttributes=["email"],
        AutoVerifiedAttributes=["email"],
        Policies={
            "PasswordPolicy": {
                "MinimumLength": 8,
                "RequireUppercase": True,
                "RequireLowercase": True,
                "RequireNumbers": True,
                "RequireSymbols": True,
                "TemporaryPasswordValidityDays": 7,
            }
        },
    )
    return resp["UserPool"]["Id"]


def ensure_app_client(cognito, user_pool_id: str, app_client_name: str) -> str:
    clients = cognito.list_user_pool_clients(
        UserPoolId=user_pool_id,
        MaxResults=60
    ).get("UserPoolClients", [])

    for c in clients:
        if c.get("ClientName") == app_client_name:
            return c["ClientId"]

    resp = cognito.create_user_pool_client(
        UserPoolId=user_pool_id,
        ClientName=app_client_name,
        GenerateSecret=False,
        ExplicitAuthFlows=["ALLOW_USER_PASSWORD_AUTH", "ALLOW_REFRESH_TOKEN_AUTH"],
        PreventUserExistenceErrors="ENABLED",
    )
    return resp["UserPoolClient"]["ClientId"]


def ensure_group(cognito, user_pool_id: str, group_name: str) -> None:
    try:
        cognito.get_group(UserPoolId=user_pool_id, GroupName=group_name)
        log(f"Group exists: {group_name}")
    except ClientError as e:
        if e.response.get("Error", {}).get("Code") == "ResourceNotFoundException":
            cognito.create_group(UserPoolId=user_pool_id, GroupName=group_name)
            log(f"Created group: {group_name}")
        else:
            raise


def ensure_user(cognito, user_pool_id: str, email: str, temp_password: str) -> None:
    try:
        cognito.admin_get_user(UserPoolId=user_pool_id, Username=email)
        log(f"User exists: {email}")
    except ClientError as e:
        if e.response.get("Error", {}).get("Code") == "UserNotFoundException":
            cognito.admin_create_user(
                UserPoolId=user_pool_id,
                Username=email,
                TemporaryPassword=temp_password,
                MessageAction="SUPPRESS",
                UserAttributes=[
                    {"Name": "email", "Value": email},
                    {"Name": "email_verified", "Value": "true"},
                ],
            )
            log(f"Created user (temp password): {email}")
        else:
            raise


def add_user_to_group(cognito, user_pool_id: str, email: str, group_name: str) -> None:
    cognito.admin_add_user_to_group(
        UserPoolId=user_pool_id,
        Username=email,
        GroupName=group_name
    )
    log(f"Assigned {email} -> {group_name}")


# -------------------------
# Lambda
# -------------------------
def get_lambda_arn(client_lambda, fn_name: str) -> Optional[str]:
    try:
        resp = client_lambda.get_function(FunctionName=fn_name)
        return resp["Configuration"]["FunctionArn"]
    except ClientError as e:
        if e.response.get("Error", {}).get("Code") == "ResourceNotFoundException":
            return None
        raise


def ensure_lambda_function(
    client_lambda,
    fn_name: str,
    role_arn: str,
    runtime: str,
    handler: str,
    zip_bytes: bytes,
    timeout: int,
    memory: int,
    env_vars: Optional[Dict[str, str]] = None,
) -> str:
    arn = get_lambda_arn(client_lambda, fn_name)

    if arn is None:
        resp = retry_on_conflict(lambda: client_lambda.create_function(
            FunctionName=fn_name,
            Runtime=runtime,
            Role=role_arn,
            Handler=handler,
            Timeout=timeout,
            MemorySize=memory,
            Code={"ZipFile": zip_bytes},
            Environment={"Variables": env_vars or {}},
            Publish=True,
        ))
        arn = resp["FunctionArn"]
        log(f"Created Lambda: {fn_name} -> {arn}")

        wait_lambda_active(client_lambda, fn_name)
        return arn

    retry_on_conflict(lambda: client_lambda.update_function_code(
        FunctionName=fn_name,
        ZipFile=zip_bytes,
        Publish=True,
    ))
    wait_lambda_active(client_lambda, fn_name)

    retry_on_conflict(lambda: client_lambda.update_function_configuration(
        FunctionName=fn_name,
        Runtime=runtime,
        Role=role_arn,
        Handler=handler,
        Timeout=timeout,
        MemorySize=memory,
        Environment={"Variables": env_vars or {}},
    ))
    wait_lambda_active(client_lambda, fn_name)

    log(f"Updated Lambda: {fn_name} -> {arn}")
    return arn


def update_lambda_configuration_only(
    client_lambda,
    fn_name: str,
    role_arn: str,
    runtime: Optional[str] = None,
    handler: Optional[str] = None,
    timeout: Optional[int] = None,
    memory: Optional[int] = None,
) -> None:
    wait_lambda_active(client_lambda, fn_name)
    kwargs: Dict[str, Any] = {"FunctionName": fn_name, "Role": role_arn}
    if runtime is not None:
        kwargs["Runtime"] = runtime
    if handler is not None:
        kwargs["Handler"] = handler
    if timeout is not None:
        kwargs["Timeout"] = timeout
    if memory is not None:
        kwargs["MemorySize"] = memory

    retry_on_conflict(lambda: client_lambda.update_function_configuration(**kwargs))
    wait_lambda_active(client_lambda, fn_name)


def merge_lambda_env_vars(
    client_lambda,
    fn_name: str,
    updates: Dict[str, Optional[str]],
) -> None:
    wait_lambda_active(client_lambda, fn_name)

    resp = client_lambda.get_function_configuration(FunctionName=fn_name)
    cur = resp.get("Environment", {}).get("Variables", {}) or {}
    merged = merge_env(cur, updates)

    retry_on_conflict(lambda: client_lambda.update_function_configuration(
        FunctionName=fn_name,
        Environment={"Variables": merged},
    ))
    wait_lambda_active(client_lambda, fn_name)


def ensure_function_url(client_lambda, fn_name: str, allowed_origin: str) -> str:
    wait_lambda_active(client_lambda, fn_name)

    cors_cfg = {
        "AllowOrigins": ["*"],          # ✅ wildcard ONLY (cannot mix with specific origins)
        "AllowMethods": ["POST"],       # keep strict to avoid validation issues
        "AllowHeaders": ["content-type", "authorization"],
        "ExposeHeaders": [],
        "MaxAge": 0,
        "AllowCredentials": False,
    }

    try:
        resp = client_lambda.get_function_url_config(FunctionName=fn_name)
        url = resp["FunctionUrl"]

        retry_on_conflict(lambda: client_lambda.update_function_url_config(
            FunctionName=fn_name,
            AuthType="NONE",
            Cors=cors_cfg,
        ))
        wait_lambda_active(client_lambda, fn_name)
        log("Function URL exists, updated CORS/Auth.")
        return url

    except ClientError as e:
        if e.response.get("Error", {}).get("Code") != "ResourceNotFoundException":
            raise

    resp = retry_on_conflict(lambda: client_lambda.create_function_url_config(
        FunctionName=fn_name,
        AuthType="NONE",
        Cors=cors_cfg,
    ))
    wait_lambda_active(client_lambda, fn_name)
    url = resp["FunctionUrl"]
    log("Created Function URL for Detector (Auth NONE).")
    return url

# -------------------------
# SNS
# -------------------------
def ensure_sns_topic_and_policy(sns, account_id: str, topic_name: str) -> str:
    topic_arn = sns.create_topic(Name=topic_name)["TopicArn"]

    policy = {
        "Version": "2008-10-17",
        "Id": "__default_policy_ID",
        "Statement": [
            {
                "Sid": "__default_statement_ID",
                "Effect": "Allow",
                "Principal": {"AWS": "*"},
                "Action": [
                    "SNS:Publish",
                    "SNS:RemovePermission",
                    "SNS:SetTopicAttributes",
                    "SNS:DeleteTopic",
                    "SNS:ListSubscriptionsByTopic",
                    "SNS:GetTopicAttributes",
                    "SNS:AddPermission",
                    "SNS:Subscribe",
                ],
                "Resource": topic_arn,
                "Condition": {"StringEquals": {"AWS:SourceAccount": account_id}},
            },
            {
                "Sid": "AllowLambdaPublish",
                "Effect": "Allow",
                "Principal": {"Service": "lambda.amazonaws.com"},
                "Action": "SNS:Publish",
                "Resource": topic_arn,
                "Condition": {"StringEquals": {"AWS:SourceAccount": account_id}},
            },
        ],
    }

    sns.set_topic_attributes(
        TopicArn=topic_arn,
        AttributeName="Policy",
        AttributeValue=json.dumps(policy),
    )
    log("SNS Access Policy updated.")
    return topic_arn


def ensure_email_subscription(sns, topic_arn: str, email: str) -> None:
    paginator = sns.get_paginator("list_subscriptions_by_topic")
    for page in paginator.paginate(TopicArn=topic_arn):
        subs = page.get("Subscriptions", [])
        for s in subs:
            if s.get("Endpoint") == email:
                log(f"SNS subscription already exists (or pending): {s.get('SubscriptionArn')}")
                return

    sns.subscribe(
        TopicArn=topic_arn,
        Protocol="email",
        Endpoint=email,
    )
    log(f"SNS subscription created for {email} (check email to CONFIRM).")


# -------------------------
# API Gateway v2 HTTP
# -------------------------
def ensure_http_api(apigw, api_name: str) -> str:
    apis = apigw.get_apis().get("Items", [])
    for a in apis:
        if a.get("Name") == api_name and a.get("ProtocolType") == "HTTP":
            api_id = a["ApiId"]
            apigw.update_api(
                ApiId=api_id,
                CorsConfiguration={
                    "AllowOrigins": ["*"],
                    "AllowHeaders": ["authorization", "content-type"],
                    "AllowMethods": ["GET", "POST", "PATCH", "OPTIONS"],
                    "AllowCredentials": False,
                    "MaxAge": 0,
                },
            )
            log("API exists, updated CORS config.")
            return api_id

    resp = apigw.create_api(
        Name=api_name,
        ProtocolType="HTTP",
        CorsConfiguration={
            "AllowOrigins": ["*"],
            "AllowHeaders": ["authorization", "content-type"],
            "AllowMethods": ["GET", "POST", "PATCH", "OPTIONS"],
            "AllowCredentials": False,
            "MaxAge": 0,
        },
    )
    api_id = resp["ApiId"]
    log(f"Created API: {api_id}")
    return api_id


def ensure_default_stage(apigw, api_id: str) -> None:
    stages = apigw.get_stages(ApiId=api_id).get("Items", [])
    for s in stages:
        if s.get("StageName") == "$default":
            return
    apigw.create_stage(ApiId=api_id, StageName="$default", AutoDeploy=False)
    log("Created $default stage.")


def ensure_integration(apigw, api_id: str, lambda_arn: str) -> str:
    integrations = apigw.get_integrations(ApiId=api_id).get("Items", [])
    for it in integrations:
        if it.get("IntegrationUri") == lambda_arn:
            return it["IntegrationId"]

    resp = apigw.create_integration(
        ApiId=api_id,
        IntegrationType="AWS_PROXY",
        IntegrationUri=lambda_arn,
        PayloadFormatVersion="2.0",
    )
    return resp["IntegrationId"]


def ensure_jwt_authorizer(apigw, api_id: str, client_id: str, issuer: str) -> str:
    AUTH_NAME = "JWT-Auth"  # ✅ no spaces. Allowed: a-zA-Z0-9._-

    auths = apigw.get_authorizers(ApiId=api_id).get("Items", [])
    for a in auths:
        if a.get("AuthorizerType") == "JWT" and a.get("Name") == AUTH_NAME:
            auth_id = a["AuthorizerId"]
            apigw.update_authorizer(
                ApiId=api_id,
                AuthorizerId=auth_id,
                JwtConfiguration={
                    "Audience": [client_id],
                    "Issuer": issuer,
                },
            )
            log("Authorizer exists, updated config.")
            return auth_id

    resp = apigw.create_authorizer(
        ApiId=api_id,
        Name=AUTH_NAME,
        AuthorizerType="JWT",
        IdentitySource=["$request.header.Authorization"],
        JwtConfiguration={
            "Audience": [client_id],
            "Issuer": issuer,
        },
    )
    auth_id = resp["AuthorizerId"]
    log(f"Created authorizer: {auth_id}")
    return auth_id


def ensure_route(
    apigw,
    api_id: str,
    route_key: str,
    integration_id: str,
    authorization_type: str = "NONE",
    authorizer_id: Optional[str] = None,
) -> None:
    routes = apigw.get_routes(ApiId=api_id).get("Items", [])
    existing = None
    for r in routes:
        if r.get("RouteKey") == route_key:
            existing = r
            break

    target = f"integrations/{integration_id}"
    if existing is None:
        kwargs: Dict[str, Any] = {
            "ApiId": api_id,
            "RouteKey": route_key,
            "Target": target,
            "AuthorizationType": authorization_type,
        }
        if authorization_type == "JWT" and authorizer_id:
            kwargs["AuthorizerId"] = authorizer_id
        apigw.create_route(**kwargs)
        log(f"Created route: {route_key} (auth={authorization_type})")
    else:
        kwargs2: Dict[str, Any] = {
            "ApiId": api_id,
            "RouteId": existing["RouteId"],
            "Target": target,
            "AuthorizationType": authorization_type,
        }
        if authorization_type == "JWT" and authorizer_id:
            kwargs2["AuthorizerId"] = authorizer_id
        apigw.update_route(**kwargs2)
        log(f"Updated route: {route_key} (auth={authorization_type})")


def deploy_api(apigw, api_id: str) -> None:
    apigw.create_deployment(ApiId=api_id)
    log("Deployed API stage.")
    # tiny buffer for propagation
    time.sleep(2)


# -------------------------
# Build Login Lambda zip
# -------------------------
def build_login_lambda_zip() -> bytes:
    # Always prefer prebuilt login.zip in the same folder as this script
    here = os.path.dirname(os.path.abspath(__file__))
    prebuilt = os.path.join(here, "login.zip")

    if os.path.exists(prebuilt):
        log(f"Using prebuilt login.zip: {prebuilt}")
        return b64_zip_bytes(prebuilt)

    need_cmd("node")
    need_cmd("npm")

    with tempfile.TemporaryDirectory() as wd:
        login_path = os.path.join(wd, "login.mjs")
        pkg_path = os.path.join(wd, "package.json")

        with open(login_path, "w", encoding="utf-8") as f:
            f.write(LOGIN_MJS)

        with open(pkg_path, "w", encoding="utf-8") as f:
            json.dump(PACKAGE_JSON, f, indent=2)

        log("Packaging Login Lambda zip (npm install)...")
        subprocess.run(["npm", "install"], cwd=wd, check=True)

        out_zip = os.path.join(wd, "lifeshot_login.zip")
        with zipfile.ZipFile(out_zip, "w", compression=zipfile.ZIP_DEFLATED) as z:
            z.write(login_path, "login.mjs")
            z.write(pkg_path, "package.json")
            nm_dir = os.path.join(wd, "node_modules")
            for root, _, files in os.walk(nm_dir):
                for f2 in files:
                    full = os.path.join(root, f2)
                    rel = os.path.relpath(full, wd)
                    z.write(full, rel)

        return b64_zip_bytes(out_zip)


# -------------------------
# Main
# -------------------------
def main() -> None:
    log(f"Region: {REGION}")

    sts = safe_client("sts")
    iam = safe_client("iam")
    cognito = safe_client("cognito-idp")
    client_lambda = safe_client("lambda")
    apigw = safe_client("apigatewayv2")
    sns = safe_client("sns")

    # Validate credentials
    try:
        sts.get_caller_identity()
    except ClientError as e:
        die(f"AWS credentials not working: {e}")

    account_id = get_account_id(sts)
    log(f"Account: {account_id}")

    # LabRole ARN
    try:
        role_arn = iam.get_role(RoleName=LAB_ROLE_NAME)["Role"]["Arn"]
    except ClientError:
        role_arn = f"arn:aws:iam::{account_id}:role/{LAB_ROLE_NAME}"
    log(f"Using LAB ROLE for Lambdas: {role_arn}")

    here = os.path.dirname(os.path.abspath(__file__))

    # 1) Cognito User Pool
    log(f"Ensuring Cognito User Pool: {USER_POOL_NAME}")
    user_pool_id = ensure_user_pool(cognito, USER_POOL_NAME)
    user_pool_arn = f"arn:aws:cognito-idp:{REGION}:{account_id}:userpool/{user_pool_id}"
    issuer = f"https://cognito-idp.{REGION}.amazonaws.com/{user_pool_id}"
    log(f"User Pool ID: {user_pool_id}")
    log(f"UserPool ARN: {user_pool_arn}")
    log(f"Issuer: {issuer}")

    # 2) App Client (no secret)
    log(f"Ensuring App Client: {APP_CLIENT_NAME}")
    client_id = ensure_app_client(cognito, user_pool_id, APP_CLIENT_NAME)
    log(f"Client ID: {client_id}")

    # 3) Groups
    log(f"Ensuring groups: {GROUP_ADMINS}, {GROUP_LIFEGUARDS}")
    ensure_group(cognito, user_pool_id, GROUP_ADMINS)
    ensure_group(cognito, user_pool_id, GROUP_LIFEGUARDS)

    # 4) Users + group assignments
    log("Ensuring users exist + group assignments")
    ensure_user(cognito, user_pool_id, ADMIN_EMAIL, TEMP_PASSWORD)
    ensure_user(cognito, user_pool_id, GUARD_EMAIL, TEMP_PASSWORD)
    add_user_to_group(cognito, user_pool_id, ADMIN_EMAIL, GROUP_ADMINS)
    add_user_to_group(cognito, user_pool_id, GUARD_EMAIL, GROUP_LIFEGUARDS)

    # 5) Build + deploy Login Lambda
    login_zip = build_login_lambda_zip()
    login_env = {
        "COGNITO_REGION": REGION,
        "COGNITO_CLIENT_ID": client_id,
        "ALLOWED_ORIGIN": ALLOWED_ORIGIN,
    }
    login_arn = ensure_lambda_function(
        client_lambda=client_lambda,
        fn_name=LOGIN_LAMBDA_NAME,
        role_arn=role_arn,
        runtime=LOGIN_RUNTIME,
        handler="login.handler",
        zip_bytes=login_zip,
        timeout=15,
        memory=256,
        env_vars=login_env,
    )

    # 6) Split lambdas: prefer real zips in deploy/ (fallback to placeholders if missing)
    log("Ensuring split Lambdas exist (Detector / Render / Events+SNS). Prefer deploy zips, fallback to placeholders if missing...")

    det_real = os.path.join(here, "detector_logic.zip")
    ren_real = os.path.join(here, "render_and_s3.zip")
    es_real = os.path.join(here, "events_and_sns.zip")

    def load_or_placeholder(real_path: str, module_name: str) -> bytes:
        if os.path.exists(real_path):
            log(f"Using zip: {real_path}")
            return b64_zip_bytes(real_path)
        log(f"Missing {real_path} -> creating placeholder zip for {module_name}")
        with tempfile.TemporaryDirectory() as td:
            outp = os.path.join(td, f"{module_name}.zip")
            make_placeholder_zip(module_name, outp)
            return b64_zip_bytes(outp)

    det_zip_bytes = load_or_placeholder(det_real, "detector_logic")
    ren_zip_bytes = load_or_placeholder(ren_real, "render_and_s3")
    es_zip_bytes = load_or_placeholder(es_real, "events_and_sns")

    detector_arn = ensure_lambda_function(
        client_lambda, DETECTOR_LAMBDA_NAME, role_arn, DEFAULT_PY_RUNTIME, DETECTOR_HANDLER,
        det_zip_bytes, DETECTOR_TIMEOUT, DETECTOR_MEMORY, env_vars={}
    )
    render_arn = ensure_lambda_function(
        client_lambda, RENDER_LAMBDA_NAME, role_arn, DEFAULT_PY_RUNTIME, RENDER_HANDLER,
        ren_zip_bytes, RENDER_TIMEOUT, RENDER_MEMORY, env_vars={}
    )
    events_sns_arn = ensure_lambda_function(
        client_lambda, EVENTS_SNS_LAMBDA_NAME, role_arn, DEFAULT_PY_RUNTIME, EVENTS_SNS_HANDLER,
        es_zip_bytes, EVENTS_SNS_TIMEOUT, EVENTS_SNS_MEMORY, env_vars={}
    )

    # 7) SNS topic + policy + subscribe + set env var on Events+SNS lambda
    log("Ensuring SNS Topic + Access Policy + Email subscription + set SNS_TOPIC_ARN on Events+SNS lambda")
    sns_topic_arn = ensure_sns_topic_and_policy(sns, account_id, SNS_TOPIC_NAME)
    log(f"SNS Topic ARN: {sns_topic_arn}")
    ensure_email_subscription(sns, sns_topic_arn, ADMIN_EMAIL)

    merge_lambda_env_vars(client_lambda, EVENTS_SNS_LAMBDA_NAME, {"SNS_TOPIC_ARN": sns_topic_arn})

    # 8) Set Detector env vars (merge-safe) + remove SNS_TOPIC_ARN
    log("Updating Detector env vars (merge-safe): set RENDER_LAMBDA_NAME/EVENTS_LAMBDA_NAME and remove SNS_TOPIC_ARN")
    merge_lambda_env_vars(client_lambda, DETECTOR_LAMBDA_NAME, {
        "RENDER_LAMBDA_NAME": RENDER_LAMBDA_NAME,
        "EVENTS_LAMBDA_NAME": EVENTS_SNS_LAMBDA_NAME,
        "SNS_TOPIC_ARN": None,
    })

    # 9) Ensure Detector Function URL (Auth NONE + CORS)
    log(f"Ensuring Detector has Function URL: {DETECTOR_LAMBDA_NAME}")
    detector_url = ensure_function_url(client_lambda, DETECTOR_LAMBDA_NAME, ALLOWED_ORIGIN)

    ensure_lambda_permission_invoke(
        client_lambda,
        fn_name=DETECTOR_LAMBDA_NAME,
        statement_id=f"{STACK_PREFIX}DetectorFunctionUrlPublic",
        principal="*",
        action="lambda:InvokeFunctionUrl",
        function_url_auth_type="NONE",
    )
    log(f"Detector Function URL: {detector_url}")

    # 10) Events API Lambda: prefer real api_handler.zip (fallback to placeholder)
    log(f"Ensuring Events API Lambda exists (used by /events): {EVENTS_API_LAMBDA_NAME} (prefer api_handler.zip)")
    events_api_arn = get_lambda_arn(client_lambda, EVENTS_API_LAMBDA_NAME)
    if events_api_arn is None:
        api_real = os.path.join(here, "api_handler.zip")
        if os.path.exists(api_real):
            log(f"Using zip: {api_real}")
            zbytes = b64_zip_bytes(api_real)
        else:
            log(f"Missing {api_real} -> creating placeholder /events API zip")
            with tempfile.TemporaryDirectory() as td:
                zpath = os.path.join(td, "events_api.zip")
                make_events_api_placeholder_zip(zpath)
                zbytes = b64_zip_bytes(zpath)

        events_api_arn = ensure_lambda_function(
            client_lambda, EVENTS_API_LAMBDA_NAME, role_arn, DEFAULT_PY_RUNTIME, "lambda_function.lambda_handler",
            zbytes, timeout=15, memory=256, env_vars={}
        )
    else:
        log(f"Events API Lambda exists: {events_api_arn}")

    # 11) Create HTTP API + stage
    log(f"Ensuring HTTP API: {API_NAME}")
    api_id = ensure_http_api(apigw, API_NAME)
    ensure_default_stage(apigw, api_id)

    api = apigw.get_api(ApiId=api_id)
    api_endpoint = api["ApiEndpoint"]
    log(f"API Endpoint: {api_endpoint}")

    # 12) Integrations
    log("Creating/Ensuring integrations")
    login_integration_id = ensure_integration(apigw, api_id, login_arn)
    events_integration_id = ensure_integration(apigw, api_id, events_api_arn)

    # 13) Lambda invoke permissions for API Gateway
    source_arn = f"arn:aws:execute-api:{REGION}:{account_id}:{api_id}/*/*/*"
    log("Ensuring Lambda invoke permission for API Gateway (Login + Events API)")

    ensure_lambda_permission_invoke(
        client_lambda,
        fn_name=LOGIN_LAMBDA_NAME,
        statement_id=f"{STACK_PREFIX}ApiGwInvokeLogin",
        principal="apigateway.amazonaws.com",
        action="lambda:InvokeFunction",
        source_arn=source_arn,
    )

    ensure_lambda_permission_invoke(
        client_lambda,
        fn_name=EVENTS_API_LAMBDA_NAME,
        statement_id=f"{STACK_PREFIX}ApiGwInvokeEventsApi",
        principal="apigateway.amazonaws.com",
        action="lambda:InvokeFunction",
        source_arn=source_arn,
    )

    # 14) JWT Authorizer (for /events only)
    log("Ensuring JWT Authorizer for /events")
    authz_id = ensure_jwt_authorizer(apigw, api_id, client_id, issuer)

    # 15) Routes
    log("Creating routes...")

    ensure_route(apigw, api_id, "POST /auth/login", login_integration_id, "NONE", None)
    ensure_route(apigw, api_id, "POST /auth/complete-password", login_integration_id, "NONE", None)
    ensure_route(apigw, api_id, "GET /auth/me", login_integration_id, "NONE", None)
    ensure_route(apigw, api_id, "POST /auth/logout", login_integration_id, "NONE", None)

    ensure_route(apigw, api_id, "GET /events", events_integration_id, "JWT", authz_id)
    ensure_route(apigw, api_id, "PATCH /events", events_integration_id, "JWT", authz_id)

    # 16) Deploy
    deploy_api(apigw, api_id)

    # -------------------------
    # Summary
    # -------------------------
    print("\n==============================")
    print("DONE ✅")
    print(f"Region:        {REGION}")
    print(f"User Pool:     {USER_POOL_NAME} ({user_pool_id})")
    print(f"App Client:    {APP_CLIENT_NAME} (ClientId: {client_id})")
    print(f"Groups:        {GROUP_ADMINS}, {GROUP_LIFEGUARDS}")
    print("Users:")
    print(f"  Admin:       {ADMIN_EMAIL}  (temp pass: {TEMP_PASSWORD}) -> {GROUP_ADMINS}")
    print(f"  Lifeguard:   {GUARD_EMAIL}  (temp pass: {TEMP_PASSWORD}) -> {GROUP_LIFEGUARDS}")
    print(f"Login Lambda:  {LOGIN_LAMBDA_NAME}")
    print(f"Events API Lambda (/events): {EVENTS_API_LAMBDA_NAME}")
    print("Split Lambdas:")
    print(f"  Detector:    {DETECTOR_LAMBDA_NAME} (handler: {DETECTOR_HANDLER}, mem: {DETECTOR_MEMORY}MB)")
    print(f"  Render:      {RENDER_LAMBDA_NAME}   (handler: {RENDER_HANDLER}, mem: {RENDER_MEMORY}MB)")
    print(f"  Events+SNS:  {EVENTS_SNS_LAMBDA_NAME} (handler: {EVENTS_SNS_HANDLER}, mem: {EVENTS_SNS_MEMORY}MB)")
    print(f"Detector Function URL: {detector_url}")
    print(f"SNS Topic:     {SNS_TOPIC_NAME}")
    print(f"SNS Topic ARN: {sns_topic_arn}")
    print(f"HTTP API:      {API_NAME} (ApiId: {api_id})")
    print(f"API Base URL:  {api_endpoint}\n")
    print("Routes:")
    print(f"  POST  {api_endpoint}/auth/login")
    print(f"  POST  {api_endpoint}/auth/complete-password")
    print(f"  GET   {api_endpoint}/auth/me")
    print(f"  POST  {api_endpoint}/auth/logout")
    print(f"  GET   {api_endpoint}/events        (JWT Auth -> Events API Lambda: {EVENTS_API_LAMBDA_NAME})")
    print(f"  PATCH {api_endpoint}/events        (JWT Auth -> Events API Lambda: {EVENTS_API_LAMBDA_NAME})")
    print("==============================\n")
    print("IMPORTANT ✅ SNS:")
    print(f"  1) Check {ADMIN_EMAIL} inbox and click CONFIRM subscription (required)")
    print(f"  2) Events+SNS Lambda env var set: SNS_TOPIC_ARN={sns_topic_arn}")
    print("  3) Detector Lambda env vars set:")
    print(f"       RENDER_LAMBDA_NAME={RENDER_LAMBDA_NAME}")
    print(f"       EVENTS_LAMBDA_NAME={EVENTS_SNS_LAMBDA_NAME}")
    print("==============================\n")
    print("CLIENT CONFIG (admin.html):")
    print(f"  window.API_BASE_URL = '{api_endpoint}';")
    print("  window.AUTH_BASE_URL = window.API_BASE_URL;")
    print(f"  window.DETECTOR_LAMBDA_URL = '{detector_url}';")
    print("==============================\n")


if __name__ == "__main__":
    try:
        main()
    except subprocess.CalledProcessError as e:
        die(f"Command failed: {e}")
    except ClientError as e:
        die(f"AWS error: {e}")
    except Exception as e:
        die(f"Unexpected error: {e}")
