 #!/usr/bin/env bash
set -euo pipefail

# ============================================================
# LifeShot Auth Stack Bootstrap (Cognito + Login Lambda + HTTP API)
# + Creates/Ensures Function URL for Detector Lambda (for client-side demo button)
#
# - Creates Cognito User Pool + App Client (no secret)
# - Creates Groups: Admins, Lifeguards
# - Creates 2 users + assigns to groups
# - Deploys Node Lambda: LifeShot_Login (LOGIN.MJS autogenerated)
# - Uses EXISTING Events Lambda (default: LifeShot_Api_Handler)
# - Creates HTTP API: LifeShotHttpApi with routes:
#     /auth/login             POST
#     /auth/complete-password POST
#     /auth/me                GET
#     /auth/logout            POST
#     /events                 GET   (JWT Auth)  -> Events Lambda
#     /events                 PATCH (JWT Auth)  -> Events Lambda
# - CORS for API Gateway: AllowOrigins ["*"], AllowHeaders ["authorization","content-type"],
#   AllowMethods ["GET","POST","PATCH","OPTIONS"], AllowCredentials false
# - ✅ NEW: Ensures Detector Lambda has a Function URL (Auth NONE) + CORS (POST/OPTIONS)
#
# Requirements:
#   - AWS CLI v2 configured (aws configure)
#   - node + npm (for packaging Login Lambda)
#
# Optional env overrides:
#   AWS_REGION=us-east-1
#   STACK_PREFIX=LifeShot
#   ALLOWED_ORIGIN=http://localhost:5500
#   EVENTS_LAMBDA_NAME=LifeShot_Api_Handler
#   DETECTOR_LAMBDA_NAME=LifeShot_detector_logic
# ============================================================

# -------------------------
# Config
# -------------------------
REGION="${AWS_REGION:-us-east-1}"
STACK_PREFIX="${STACK_PREFIX:-LifeShot}"

USER_POOL_NAME="${USER_POOL_NAME:-${STACK_PREFIX}_UserPool}"
APP_CLIENT_NAME="${APP_CLIENT_NAME:-lifeshot-spa}"

LOGIN_LAMBDA_NAME="${LOGIN_LAMBDA_NAME:-${STACK_PREFIX}_Login}"
# ✅ This is the one you already have in AWS that talks to DynamoDB, etc.
EVENTS_LAMBDA_NAME="${EVENTS_LAMBDA_NAME:-LifeShot_Api_Handler}"

# ✅ NEW: Detector Lambda (the one you want to trigger from the demo page)
DETECTOR_LAMBDA_NAME="${DETECTOR_LAMBDA_NAME:-LifeShot_detector_logic}"

API_NAME="${API_NAME:-${STACK_PREFIX}HttpApi}"

ROLE_NAME="${ROLE_NAME:-${STACK_PREFIX}LoginLambdaRole}"

ALLOWED_ORIGIN="${ALLOWED_ORIGIN:-http://localhost:5500}"

# Users to create
ADMIN_EMAIL="${ADMIN_EMAIL:-lifeguard647@gmail.com}"
GUARD_EMAIL="${GUARD_EMAIL:-lifeguarduser1@gmail.com}"
TEMP_PASSWORD="${TEMP_PASSWORD:-LifeShot!123}"

# Groups (case-insensitive in our role mapping, but keep as requested)
GROUP_ADMINS="Admins"
GROUP_LIFEGUARDS="Lifeguards"

# -------------------------
# Helpers
# -------------------------
log() { echo "[$(date +'%H:%M:%S')] $*"; }
die() { echo "ERROR: $*" >&2; exit 1; }

need() { command -v "$1" >/dev/null 2>&1 || die "Missing command: $1"; }

need aws
need zip
need npm

aws sts get-caller-identity --region "$REGION" >/dev/null
ACCOUNT_ID="$(aws sts get-caller-identity --query Account --output text --region "$REGION")"
log "Account: $ACCOUNT_ID | Region: $REGION"

# -------------------------
# 1) Create IAM role for Login Lambda
# -------------------------
log "Ensuring IAM role: $ROLE_NAME"

cat > /tmp/lambda-trust.json <<'JSON'
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Principal": { "Service": "lambda.amazonaws.com" },
    "Action": "sts:AssumeRole"
  }]
}
JSON

ROLE_ARN="$(aws iam get-role --role-name "$ROLE_NAME" --query Role.Arn --output text 2>/dev/null || true)"
if [[ -z "${ROLE_ARN}" || "${ROLE_ARN}" == "None" ]]; then
  ROLE_ARN="$(aws iam create-role \
    --role-name "$ROLE_NAME" \
    --assume-role-policy-document file:///tmp/lambda-trust.json \
    --query Role.Arn --output text)"
  log "Created role: $ROLE_ARN"
else
  log "Role exists: $ROLE_ARN"
fi

# Basic logging
aws iam attach-role-policy \
  --role-name "$ROLE_NAME" \
  --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole >/dev/null || true

# -------------------------
# 2) Create Cognito User Pool
# -------------------------
log "Ensuring Cognito User Pool: $USER_POOL_NAME"

USER_POOL_ID="$(aws cognito-idp list-user-pools \
  --region "$REGION" \
  --max-results 60 \
  --query "UserPools[?Name=='$USER_POOL_NAME'].Id | [0]" \
  --output text 2>/dev/null || true)"

if [[ -z "${USER_POOL_ID}" || "${USER_POOL_ID}" == "None" ]]; then
  USER_POOL_ID="$(aws cognito-idp create-user-pool \
    --region "$REGION" \
    --pool-name "$USER_POOL_NAME" \
    --username-attributes email \
    --auto-verified-attributes email \
    --policies 'PasswordPolicy={MinimumLength=8,RequireUppercase=true,RequireLowercase=true,RequireNumbers=true,RequireSymbols=true,TemporaryPasswordValidityDays=7}' \
    --query UserPool.Id --output text)"
  log "Created User Pool: $USER_POOL_ID"
else
  log "User Pool exists: $USER_POOL_ID"
fi

USER_POOL_ARN="arn:aws:cognito-idp:${REGION}:${ACCOUNT_ID}:userpool/${USER_POOL_ID}"
ISSUER="https://cognito-idp.${REGION}.amazonaws.com/${USER_POOL_ID}"
log "UserPool ARN: $USER_POOL_ARN"
log "Issuer: $ISSUER"

# -------------------------
# 3) Create App Client (NO secret)
# -------------------------
log "Ensuring App Client: $APP_CLIENT_NAME"

CLIENT_ID="$(aws cognito-idp list-user-pool-clients \
  --region "$REGION" \
  --user-pool-id "$USER_POOL_ID" \
  --max-results 60 \
  --query "UserPoolClients[?ClientName=='$APP_CLIENT_NAME'].ClientId | [0]" \
  --output text 2>/dev/null || true)"

if [[ -z "${CLIENT_ID}" || "${CLIENT_ID}" == "None" ]]; then
  CLIENT_ID="$(aws cognito-idp create-user-pool-client \
    --region "$REGION" \
    --user-pool-id "$USER_POOL_ID" \
    --client-name "$APP_CLIENT_NAME" \
    --generate-secret false \
    --explicit-auth-flows ALLOW_USER_PASSWORD_AUTH ALLOW_REFRESH_TOKEN_AUTH \
    --prevent-user-existence-errors ENABLED \
    --query UserPoolClient.ClientId --output text)"
  log "Created App Client ID: $CLIENT_ID"
else
  log "App Client exists: $CLIENT_ID"
fi

# -------------------------
# 4) Create Groups
# -------------------------
log "Ensuring groups: $GROUP_ADMINS, $GROUP_LIFEGUARDS"

ensure_group() {
  local g="$1"
  if aws cognito-idp get-group --region "$REGION" --user-pool-id "$USER_POOL_ID" --group-name "$g" >/dev/null 2>&1; then
    log "Group exists: $g"
  else
    aws cognito-idp create-group --region "$REGION" --user-pool-id "$USER_POOL_ID" --group-name "$g" >/dev/null
    log "Created group: $g"
  fi
}

ensure_group "$GROUP_ADMINS"
ensure_group "$GROUP_LIFEGUARDS"

# -------------------------
# 5) Create Users (AdminCreateUser) + Assign to Groups
# -------------------------
log "Ensuring users exist + group assignments"

ensure_user() {
  local email="$1"
  if aws cognito-idp admin-get-user --region "$REGION" --user-pool-id "$USER_POOL_ID" --username "$email" >/dev/null 2>&1; then
    log "User exists: $email"
  else
    aws cognito-idp admin-create-user \
      --region "$REGION" \
      --user-pool-id "$USER_POOL_ID" \
      --username "$email" \
      --temporary-password "$TEMP_PASSWORD" \
      --message-action SUPPRESS \
      --user-attributes Name=email,Value="$email" Name=email_verified,Value=true >/dev/null
    log "Created user (temp password): $email"
  fi
}

add_to_group() {
  local email="$1"
  local group="$2"
  aws cognito-idp admin-add-user-to-group \
    --region "$REGION" \
    --user-pool-id "$USER_POOL_ID" \
    --username "$email" \
    --group-name "$group" >/dev/null
  log "Assigned $email -> $group"
}

ensure_user "$ADMIN_EMAIL"
ensure_user "$GUARD_EMAIL"

add_to_group "$ADMIN_EMAIL" "$GROUP_ADMINS"
add_to_group "$GUARD_EMAIL" "$GROUP_LIFEGUARDS"

# -------------------------
# 6) Attach inline policy to Lambda role (Cognito calls)
# -------------------------
log "Updating IAM inline policy for Cognito calls on $USER_POOL_ARN"

cat > /tmp/login-inline-policy.json <<JSON
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "CognitoAuthCalls",
      "Effect": "Allow",
      "Action": [
        "cognito-idp:InitiateAuth",
        "cognito-idp:RespondToAuthChallenge"
      ],
      "Resource": "${USER_POOL_ARN}"
    },
    {
      "Sid": "CognitoAdminForBootstrapOptional",
      "Effect": "Allow",
      "Action": [
        "cognito-idp:AdminGetUser"
      ],
      "Resource": "${USER_POOL_ARN}"
    }
  ]
}
JSON

aws iam put-role-policy \
  --role-name "$ROLE_NAME" \
  --policy-name "${STACK_PREFIX}LoginCognitoPolicy" \
  --policy-document file:///tmp/login-inline-policy.json >/dev/null

log "Waiting for IAM propagation..."
sleep 8

# -------------------------
# 7) Generate LOGIN.MJS (with complete-password)
# -------------------------
WORKDIR="$(mktemp -d)"
trap 'rm -rf "$WORKDIR"' EXIT

log "Generating LOGIN.MJS in $WORKDIR"

cat > "$WORKDIR/login.mjs" <<'MJS'
import {
  CognitoIdentityProviderClient,
  InitiateAuthCommand,
  RespondToAuthChallengeCommand,
} from "@aws-sdk/client-cognito-identity-provider";

// ===============================
// ENV
// ===============================
const REGION = process.env.COGNITO_REGION || "us-east-1";
const CLIENT_ID = process.env.COGNITO_CLIENT_ID;
const ALLOWED_ORIGIN = process.env.ALLOWED_ORIGIN || "http://localhost:5500";

if (!CLIENT_ID) console.warn("Missing env COGNITO_CLIENT_ID");

const cognito = new CognitoIdentityProviderClient({ region: REGION });

// ===============================
// HELPERS
// ===============================
function corsHeaders(origin) {
  const reqOrigin = origin || "";
  const allowOrigin = reqOrigin && reqOrigin === ALLOWED_ORIGIN ? reqOrigin : ALLOWED_ORIGIN;

  return {
    "Access-Control-Allow-Origin": allowOrigin,
    "Access-Control-Allow-Headers": "content-type,authorization",
    "Access-Control-Allow-Methods": "GET,POST,PATCH,OPTIONS",
    "Access-Control-Allow-Credentials": "false",
    "Vary": "Origin",
  };
}

function json(statusCode, bodyObj, origin, extraHeaders = {}) {
  return {
    statusCode,
    headers: {
      "Content-Type": "application/json",
      ...corsHeaders(origin),
      ...extraHeaders,
    },
    body: JSON.stringify(bodyObj),
  };
}

function parseJsonBody(event) {
  try {
    if (!event.body) return {};
    return typeof event.body === "string" ? JSON.parse(event.body) : event.body;
  } catch {
    return {};
  }
}

function decodeJwtPayload(token) {
  try {
    const parts = String(token || "").split(".");
    if (parts.length < 2) return null;
    const b64 = parts[1].replace(/-/g, "+").replace(/_/g, "/");
    const padded = b64 + "===".slice((b64.length + 3) % 4);
    const jsonStr = Buffer.from(padded, "base64").toString("utf8");
    return JSON.parse(jsonStr);
  } catch {
    return null;
  }
}

function getRoleFromGroups(groups) {
  const g = (groups || []).map((x) => String(x).toLowerCase());
  if (g.includes("admins") || g.includes("admin")) return "admin";
  if (g.includes("lifeguards") || g.includes("lifeguard") || g.includes("guard")) return "guard";
  return "unknown";
}

function getBearerToken(event) {
  const h = event.headers || {};
  const auth = h.authorization || h.Authorization || "";
  const m = String(auth).match(/^Bearer\s+(.+)$/i);
  return m ? m[1].trim() : "";
}

// ===============================
// ROUTES
// ===============================
async function routeLogin(event, origin) {
  const body = parseJsonBody(event);
  const username = String(body.username || "").trim();
  const password = String(body.password || "").trim();

  if (!username || !password) {
    return json(400, { message: "username and password are required" }, origin);
  }

  const cmd = new InitiateAuthCommand({
    AuthFlow: "USER_PASSWORD_AUTH",
    ClientId: CLIENT_ID,
    AuthParameters: { USERNAME: username, PASSWORD: password },
  });

  try {
    const resp = await cognito.send(cmd);

    if (resp.ChallengeName === "NEW_PASSWORD_REQUIRED") {
      const challengeUsername =
        resp.ChallengeParameters?.USER_ID_FOR_SRP || username;

      return json(
        409,
        {
          ok: false,
          challenge: "NEW_PASSWORD_REQUIRED",
          session: resp.Session || "",
          username: challengeUsername,
          message: "New password required",
        },
        origin
      );
    }

    const auth = resp.AuthenticationResult || {};
    const accessToken = auth.AccessToken || "";
    const idToken = auth.IdToken || "";
    const refreshToken = auth.RefreshToken || "";
    const expiresIn = Number(auth.ExpiresIn || 3600);

    if (!accessToken || !idToken) {
      return json(401, { message: "Login failed (no tokens returned)" }, origin);
    }

    const payload = decodeJwtPayload(idToken) || {};
    const groups = Array.isArray(payload["cognito:groups"]) ? payload["cognito:groups"] : [];
    const role = getRoleFromGroups(groups);

    return json(
      200,
      {
        ok: true,
        role,
        username: payload["cognito:username"] || username,
        email: payload["email"] || "",
        groups,
        expiresIn,
        accessToken,
        idToken,
        refreshToken,
      },
      origin
    );
  } catch (err) {
    return json(
      401,
      { message: "Login failed", detail: err?.name || "AuthError", reason: err?.message || "" },
      origin
    );
  }
}

async function routeCompletePassword(event, origin) {
  const body = parseJsonBody(event);
  const username = String(body.username || "").trim();
  const newPassword = String(body.newPassword || "").trim();
  const session = String(body.session || "").trim();

  if (!username || !newPassword || !session) {
    return json(400, { message: "username, newPassword and session are required" }, origin);
  }

  const cmd = new RespondToAuthChallengeCommand({
    ClientId: CLIENT_ID,
    ChallengeName: "NEW_PASSWORD_REQUIRED",
    Session: session,
    ChallengeResponses: {
      USERNAME: username,
      NEW_PASSWORD: newPassword,
    },
  });

  try {
    const resp = await cognito.send(cmd);
    const auth = resp.AuthenticationResult || {};

    const accessToken = auth.AccessToken || "";
    const idToken = auth.IdToken || "";
    const refreshToken = auth.RefreshToken || "";
    const expiresIn = Number(auth.ExpiresIn || 3600);

    if (!accessToken || !idToken) {
      return json(401, { message: "Password change succeeded but no tokens returned" }, origin);
    }

    const payload = decodeJwtPayload(idToken) || {};
    const groups = Array.isArray(payload["cognito:groups"]) ? payload["cognito:groups"] : [];
    const role = getRoleFromGroups(groups);

    return json(
      200,
      {
        ok: true,
        role,
        username: payload["cognito:username"] || username,
        email: payload["email"] || "",
        groups,
        expiresIn,
        accessToken,
        idToken,
        refreshToken,
      },
      origin
    );
  } catch (err) {
    return json(
      401,
      { message: "Password change failed", detail: err?.name || "ChallengeError", reason: err?.message || "" },
      origin
    );
  }
}

async function routeMe(event, origin) {
  const token = getBearerToken(event);
  if (!token) return json(401, { ok: false, message: "Missing Bearer token" }, origin);

  const payload = decodeJwtPayload(token);
  if (!payload) return json(401, { ok: false, message: "Invalid token" }, origin);

  const groups = Array.isArray(payload["cognito:groups"]) ? payload["cognito:groups"] : [];
  const role = getRoleFromGroups(groups);

  return json(
    200,
    {
      ok: true,
      role,
      username: payload["cognito:username"] || payload["username"] || "",
      email: payload["email"] || "",
      groups,
    },
    origin
  );
}

async function routeLogout(event, origin) {
  return json(200, { ok: true }, origin);
}

// NOTE: We intentionally do NOT handle /events here anymore.
// /events routes will go to your Events Lambda (LifeShot_Api_Handler).
export const handler = async (event) => {
  const method = event.requestContext?.http?.method || event.httpMethod || "";
  const path = event.requestContext?.http?.path || event.rawPath || event.path || "";
  const origin = event.headers?.origin || event.headers?.Origin || "";

  if (method === "OPTIONS") {
    return { statusCode: 204, headers: corsHeaders(origin), body: "" };
  }

  if (method === "POST" && path.endsWith("/auth/login")) return routeLogin(event, origin);
  if (method === "POST" && path.endsWith("/auth/complete-password")) return routeCompletePassword(event, origin);
  if (method === "GET"  && path.endsWith("/auth/me")) return routeMe(event, origin);
  if (method === "POST" && path.endsWith("/auth/logout")) return routeLogout(event, origin);

  return json(404, { message: "Not found", path, method }, origin);
};
MJS

cat > "$WORKDIR/package.json" <<'JSON'
{
  "name": "lifeshot-login",
  "version": "1.0.0",
  "type": "module",
  "dependencies": {
    "@aws-sdk/client-cognito-identity-provider": "^3.600.0"
  }
}
JSON

log "Packaging Lambda zip (with node_modules)..."
pushd "$WORKDIR" >/dev/null
npm install --silent
zip -qr /tmp/lifeshot_login.zip login.mjs package.json node_modules
popd >/dev/null

# -------------------------
# 8) Create/Update Login Lambda
# -------------------------
log "Deploying Lambda: $LOGIN_LAMBDA_NAME"

LOGIN_ARN="$(aws lambda get-function --region "$REGION" --function-name "$LOGIN_LAMBDA_NAME" --query Configuration.FunctionArn --output text 2>/dev/null || true)"

if [[ -z "${LOGIN_ARN}" || "${LOGIN_ARN}" == "None" ]]; then
  LOGIN_ARN="$(aws lambda create-function \
    --region "$REGION" \
    --function-name "$LOGIN_LAMBDA_NAME" \
    --runtime nodejs20.x \
    --role "$ROLE_ARN" \
    --handler "login.handler" \
    --timeout 15 \
    --memory-size 256 \
    --zip-file "fileb:///tmp/lifeshot_login.zip" \
    --environment "Variables={COGNITO_REGION=$REGION,COGNITO_CLIENT_ID=$CLIENT_ID,ALLOWED_ORIGIN=$ALLOWED_ORIGIN}" \
    --query FunctionArn --output text)"
  log "Created Lambda: $LOGIN_ARN"
else
  aws lambda update-function-code \
    --region "$REGION" \
    --function-name "$LOGIN_LAMBDA_NAME" \
    --zip-file "fileb:///tmp/lifeshot_login.zip" >/dev/null

  aws lambda update-function-configuration \
    --region "$REGION" \
    --function-name "$LOGIN_LAMBDA_NAME" \
    --runtime nodejs20.x \
    --role "$ROLE_ARN" \
    --handler "login.handler" \
    --timeout 15 \
    --memory-size 256 \
    --environment "Variables={COGNITO_REGION=$REGION,COGNITO_CLIENT_ID=$CLIENT_ID,ALLOWED_ORIGIN=$ALLOWED_ORIGIN}" >/dev/null

  LOGIN_ARN="$(aws lambda get-function --region "$REGION" --function-name "$LOGIN_LAMBDA_NAME" --query Configuration.FunctionArn --output text)"
  log "Updated Lambda: $LOGIN_ARN"
fi

# -------------------------
# ✅ 8.5) Ensure DETECTOR Function URL (Auth NONE + CORS)
# -------------------------
log "Ensuring Detector Lambda exists + has Function URL: $DETECTOR_LAMBDA_NAME"

DETECTOR_ARN="$(aws lambda get-function --region "$REGION" --function-name "$DETECTOR_LAMBDA_NAME" --query Configuration.FunctionArn --output text 2>/dev/null || true)"
[[ -z "${DETECTOR_ARN}" || "${DETECTOR_ARN}" == "None" ]] && die "Detector Lambda not found: $DETECTOR_LAMBDA_NAME (create it first)"

# Try to read existing Function URL config
DETECTOR_FUNCTION_URL="$(aws lambda get-function-url-config \
  --region "$REGION" \
  --function-name "$DETECTOR_LAMBDA_NAME" \
  --query FunctionUrl --output text 2>/dev/null || true)"

# Create or update Function URL config (Auth NONE) + CORS (POST/OPTIONS)
if [[ -z "${DETECTOR_FUNCTION_URL}" || "${DETECTOR_FUNCTION_URL}" == "None" ]]; then
  log "Creating Function URL for Detector (Auth NONE)..."
  DETECTOR_FUNCTION_URL="$(aws lambda create-function-url-config \
    --region "$REGION" \
    --function-name "$DETECTOR_LAMBDA_NAME" \
    --auth-type NONE \
    --cors "AllowOrigins=['$ALLOWED_ORIGIN','*'],AllowMethods=['POST','OPTIONS'],AllowHeaders=['content-type','authorization'],ExposeHeaders=[],MaxAge=0,AllowCredentials=false" \
    --query FunctionUrl --output text)"
else
  log "Function URL exists, updating CORS/Auth settings..."
  aws lambda update-function-url-config \
    --region "$REGION" \
    --function-name "$DETECTOR_LAMBDA_NAME" \
    --auth-type NONE \
    --cors "AllowOrigins=['$ALLOWED_ORIGIN','*'],AllowMethods=['POST','OPTIONS'],AllowHeaders=['content-type','authorization'],ExposeHeaders=[],MaxAge=0,AllowCredentials=false" >/dev/null

  DETECTOR_FUNCTION_URL="$(aws lambda get-function-url-config \
    --region "$REGION" \
    --function-name "$DETECTOR_LAMBDA_NAME" \
    --query FunctionUrl --output text)"
fi

# For Function URL with AuthType=NONE you must allow public InvokeFunctionUrl (resource-based policy)
log "Ensuring public permission for Detector Function URL (InvokeFunctionUrl, AuthType=NONE)..."
aws lambda add-permission \
  --region "$REGION" \
  --function-name "$DETECTOR_LAMBDA_NAME" \
  --statement-id "${STACK_PREFIX}DetectorFunctionUrlPublic" \
  --action lambda:InvokeFunctionUrl \
  --principal "*" \
  --function-url-auth-type NONE >/dev/null 2>&1 || true

log "Detector Function URL: $DETECTOR_FUNCTION_URL"

# -------------------------
# 9) Create HTTP API (with CORS)
# -------------------------
log "Ensuring HTTP API: $API_NAME"

API_ID="$(aws apigatewayv2 get-apis \
  --region "$REGION" \
  --query "Items[?Name=='$API_NAME' && ProtocolType=='HTTP'].ApiId | [0]" \
  --output text 2>/dev/null || true)"

if [[ -z "${API_ID}" || "${API_ID}" == "None" ]]; then
  API_ID="$(aws apigatewayv2 create-api \
    --region "$REGION" \
    --name "$API_NAME" \
    --protocol-type HTTP \
    --cors-configuration "AllowOrigins=['*'],AllowHeaders=['authorization','content-type'],AllowMethods=['GET','POST','PATCH','OPTIONS'],AllowCredentials=false,MaxAge=0" \
    --query ApiId --output text)"
  log "Created API: $API_ID"
else
  log "API exists: $API_ID"
  aws apigatewayv2 update-api \
    --region "$REGION" \
    --api-id "$API_ID" \
    --cors-configuration "AllowOrigins=['*'],AllowHeaders=['authorization','content-type'],AllowMethods=['GET','POST','PATCH','OPTIONS'],AllowCredentials=false,MaxAge=0" >/dev/null
  log "Updated API CORS config"
fi

STAGE_NAME="\$default"
aws apigatewayv2 create-stage --region "$REGION" --api-id "$API_ID" --stage-name "$STAGE_NAME" >/dev/null 2>&1 || true

# -------------------------
# 10) Create Lambda Integrations
# -------------------------
log "Creating/Ensuring integration to Login Lambda: $LOGIN_LAMBDA_NAME"

LOGIN_INTEGRATION_ID="$(aws apigatewayv2 get-integrations \
  --region "$REGION" \
  --api-id "$API_ID" \
  --query "Items[?IntegrationUri=='$LOGIN_ARN'].IntegrationId | [0]" \
  --output text 2>/dev/null || true)"

if [[ -z "${LOGIN_INTEGRATION_ID}" || "${LOGIN_INTEGRATION_ID}" == "None" ]]; then
  LOGIN_INTEGRATION_ID="$(aws apigatewayv2 create-integration \
    --region "$REGION" \
    --api-id "$API_ID" \
    --integration-type AWS_PROXY \
    --integration-uri "$LOGIN_ARN" \
    --payload-format-version "2.0" \
    --query IntegrationId --output text)"
  log "Created login integration: $LOGIN_INTEGRATION_ID"
else
  log "Login integration exists: $LOGIN_INTEGRATION_ID"
fi

# ✅ Events Lambda ARN (must already exist)
log "Resolving Events Lambda ARN: $EVENTS_LAMBDA_NAME"
EVENTS_ARN="$(aws lambda get-function --region "$REGION" --function-name "$EVENTS_LAMBDA_NAME" --query Configuration.FunctionArn --output text 2>/dev/null || true)"
[[ -z "${EVENTS_ARN}" || "${EVENTS_ARN}" == "None" ]] && die "Events Lambda not found: $EVENTS_LAMBDA_NAME (create it first)"

log "Creating/Ensuring integration to Events Lambda: $EVENTS_LAMBDA_NAME"
EVENTS_INTEGRATION_ID="$(aws apigatewayv2 get-integrations \
  --region "$REGION" \
  --api-id "$API_ID" \
  --query "Items[?IntegrationUri=='$EVENTS_ARN'].IntegrationId | [0]" \
  --output text 2>/dev/null || true)"

if [[ -z "${EVENTS_INTEGRATION_ID}" || "${EVENTS_INTEGRATION_ID}" == "None" ]]; then
  EVENTS_INTEGRATION_ID="$(aws apigatewayv2 create-integration \
    --region "$REGION" \
    --api-id "$API_ID" \
    --integration-type AWS_PROXY \
    --integration-uri "$EVENTS_ARN" \
    --payload-format-version "2.0" \
    --query IntegrationId --output text)"
  log "Created events integration: $EVENTS_INTEGRATION_ID"
else
  log "Events integration exists: $EVENTS_INTEGRATION_ID"
fi

# Permissions for API Gateway to invoke Lambdas
log "Ensuring Lambda invoke permission for API Gateway (Login + Events)"
SOURCE_ARN="arn:aws:execute-api:${REGION}:${ACCOUNT_ID}:${API_ID}/*/*/*"

aws lambda add-permission \
  --region "$REGION" \
  --function-name "$LOGIN_LAMBDA_NAME" \
  --statement-id "${STACK_PREFIX}ApiGwInvokeLogin" \
  --action lambda:InvokeFunction \
  --principal apigateway.amazonaws.com \
  --source-arn "$SOURCE_ARN" >/dev/null 2>&1 || true

aws lambda add-permission \
  --region "$REGION" \
  --function-name "$EVENTS_LAMBDA_NAME" \
  --statement-id "${STACK_PREFIX}ApiGwInvokeEvents" \
  --action lambda:InvokeFunction \
  --principal apigateway.amazonaws.com \
  --source-arn "$SOURCE_ARN" >/dev/null 2>&1 || true

# -------------------------
# 11) Create JWT Authorizer (for /events only)
# -------------------------
log "Ensuring JWT Authorizer for /events"

AUTHZ_ID="$(aws apigatewayv2 get-authorizers \
  --region "$REGION" \
  --api-id "$API_ID" \
  --query "Items[?AuthorizerType=='JWT' && Name=='JWT Auth'].AuthorizerId | [0]" \
  --output text 2>/dev/null || true)"

if [[ -z "${AUTHZ_ID}" || "${AUTHZ_ID}" == "None" ]]; then
  AUTHZ_ID="$(aws apigatewayv2 create-authorizer \
    --region "$REGION" \
    --api-id "$API_ID" \
    --name "JWT Auth" \
    --authorizer-type JWT \
    --identity-source "\$request.header.Authorization" \
    --jwt-configuration "Audience=['$CLIENT_ID'],Issuer='$ISSUER'" \
    --query AuthorizerId --output text)"
  log "Created authorizer: $AUTHZ_ID"
else
  log "Authorizer exists: $AUTHZ_ID"
  aws apigatewayv2 update-authorizer \
    --region "$REGION" \
    --api-id "$API_ID" \
    --authorizer-id "$AUTHZ_ID" \
    --jwt-configuration "Audience=['$CLIENT_ID'],Issuer='$ISSUER'" >/dev/null
  log "Updated authorizer config"
fi

# -------------------------
# 12) Create Routes + Attach Integrations
# -------------------------
log "Creating routes..."

create_route() {
  local method="$1"
  local path="$2"
  local auth_type="${3:-NONE}"           # NONE | JWT
  local authorizer_id="${4:-}"           # used if JWT
  local target_integration_id="${5:-$LOGIN_INTEGRATION_ID}"
  local route_key="${method} ${path}"

  local existing
  existing="$(aws apigatewayv2 get-routes --region "$REGION" --api-id "$API_ID" \
    --query "Items[?RouteKey=='$route_key'].RouteId | [0]" --output text 2>/dev/null || true)"

  if [[ -z "${existing}" || "${existing}" == "None" ]]; then
    if [[ "$auth_type" == "JWT" ]]; then
      aws apigatewayv2 create-route \
        --region "$REGION" \
        --api-id "$API_ID" \
        --route-key "$route_key" \
        --authorization-type JWT \
        --authorizer-id "$authorizer_id" \
        --target "integrations/$target_integration_id" >/dev/null
    else
      aws apigatewayv2 create-route \
        --region "$REGION" \
        --api-id "$API_ID" \
        --route-key "$route_key" \
        --authorization-type NONE \
        --target "integrations/$target_integration_id" >/dev/null
    fi
    log "Created route: $route_key (auth=$auth_type)"
  else
    if [[ "$auth_type" == "JWT" ]]; then
      aws apigatewayv2 update-route \
        --region "$REGION" \
        --api-id "$API_ID" \
        --route-id "$existing" \
        --authorization-type JWT \
        --authorizer-id "$authorizer_id" \
        --target "integrations/$target_integration_id" >/dev/null
    else
      aws apigatewayv2 update-route \
        --region "$REGION" \
        --api-id "$API_ID" \
        --route-id "$existing" \
        --authorization-type NONE \
        --target "integrations/$target_integration_id" >/dev/null
    fi
    log "Updated route: $route_key (auth=$auth_type)"
  fi
}

# Auth routes -> Login Lambda integration
create_route "POST" "/auth/login" "NONE" "" "$LOGIN_INTEGRATION_ID"
create_route "POST" "/auth/complete-password" "NONE" "" "$LOGIN_INTEGRATION_ID"
create_route "GET"  "/auth/me" "NONE" "" "$LOGIN_INTEGRATION_ID"
create_route "POST" "/auth/logout" "NONE" "" "$LOGIN_INTEGRATION_ID"

# Events routes -> Events Lambda integration + JWT
create_route "GET"   "/events" "JWT" "$AUTHZ_ID" "$EVENTS_INTEGRATION_ID"
create_route "PATCH" "/events" "JWT" "$AUTHZ_ID" "$EVENTS_INTEGRATION_ID"

# -------------------------
# 13) Deploy API
# -------------------------
log "Deploying API stage..."
aws apigatewayv2 create-deployment --region "$REGION" --api-id "$API_ID" >/dev/null

API_ENDPOINT="$(aws apigatewayv2 get-api --region "$REGION" --api-id "$API_ID" --query ApiEndpoint --output text)"
log "API Endpoint: $API_ENDPOINT"

# -------------------------
# Summary
# -------------------------
echo
echo "=============================="
echo "DONE ✅"
echo "Region:        $REGION"
echo "User Pool:     $USER_POOL_NAME ($USER_POOL_ID)"
echo "App Client:    $APP_CLIENT_NAME (ClientId: $CLIENT_ID)"
echo "Groups:        $GROUP_ADMINS, $GROUP_LIFEGUARDS"
echo "Users:"
echo "  Admin:       $ADMIN_EMAIL  (temp pass: $TEMP_PASSWORD) -> $GROUP_ADMINS"
echo "  Lifeguard:   $GUARD_EMAIL  (temp pass: $TEMP_PASSWORD) -> $GROUP_LIFEGUARDS"
echo "Login Lambda:  $LOGIN_LAMBDA_NAME"
echo "Events Lambda: $EVENTS_LAMBDA_NAME"
echo "Detector Lambda: $DETECTOR_LAMBDA_NAME"
echo "Detector Function URL: $DETECTOR_FUNCTION_URL"
echo "HTTP API:      $API_NAME (ApiId: $API_ID)"
echo "API Base URL:  $API_ENDPOINT"
echo
echo "Routes:"
echo "  POST  $API_ENDPOINT/auth/login"
echo "  POST  $API_ENDPOINT/auth/complete-password"
echo "  GET   $API_ENDPOINT/auth/me"
echo "  POST  $API_ENDPOINT/auth/logout"
echo "  GET   $API_ENDPOINT/events        (JWT Auth -> Events Lambda)"
echo "  PATCH $API_ENDPOINT/events        (JWT Auth -> Events Lambda)"
echo "=============================="
echo
echo "CLIENT CONFIG (admin.html):"
echo "  window.API_BASE_URL = '$API_ENDPOINT';"
echo "  window.AUTH_BASE_URL = window.API_BASE_URL;"
echo "  window.DETECTOR_LAMBDA_URL = '$DETECTOR_FUNCTION_URL';"
echo "=============================="
